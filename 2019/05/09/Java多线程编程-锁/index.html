<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,多线程," />










<meta name="description" content="并发编程的问题引入原子性原子性这个问题，聊得最多的demo还是 i++ 问题， i++ 看起来是一步操作，其实做了两个运算，先加1再重新赋值给i；如果多个线程都会来操作这个 i++ 操作的时候就很可能会出现线程 A 执行的时候 加了1但是还没赋值，然后B又来加了个1，最后A再运行赋值操作，这也就是天天挂在嘴边上的原子性的例子了，就不给demo举例了。 可见性可见性是指当多个线程访问同一个变量时，一">
<meta name="keywords" content="Java,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程编程-锁">
<meta property="og:url" content="http://losergzr.cn/2019/05/09/Java多线程编程-锁/index.html">
<meta property="og:site_name" content="losergzr&#39;s blog">
<meta property="og:description" content="并发编程的问题引入原子性原子性这个问题，聊得最多的demo还是 i++ 问题， i++ 看起来是一步操作，其实做了两个运算，先加1再重新赋值给i；如果多个线程都会来操作这个 i++ 操作的时候就很可能会出现线程 A 执行的时候 加了1但是还没赋值，然后B又来加了个1，最后A再运行赋值操作，这也就是天天挂在嘴边上的原子性的例子了，就不给demo举例了。 可见性可见性是指当多个线程访问同一个变量时，一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://user-images.githubusercontent.com/20592210/57584778-d29e6300-7511-11e9-9cea-65ac04c6e31f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/20592210/57590966-8b3fc300-7561-11e9-9820-a2df4ead835e.png">
<meta property="og:updated_time" content="2019-05-13T14:34:34.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程编程-锁">
<meta name="twitter:description" content="并发编程的问题引入原子性原子性这个问题，聊得最多的demo还是 i++ 问题， i++ 看起来是一步操作，其实做了两个运算，先加1再重新赋值给i；如果多个线程都会来操作这个 i++ 操作的时候就很可能会出现线程 A 执行的时候 加了1但是还没赋值，然后B又来加了个1，最后A再运行赋值操作，这也就是天天挂在嘴边上的原子性的例子了，就不给demo举例了。 可见性可见性是指当多个线程访问同一个变量时，一">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/20592210/57584778-d29e6300-7511-11e9-9cea-65ac04c6e31f.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://losergzr.cn/2019/05/09/Java多线程编程-锁/"/>





  <title>Java多线程编程-锁 | losergzr's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">losergzr's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://losergzr.cn/2019/05/09/Java多线程编程-锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ggzr">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://user-images.githubusercontent.com/20592210/55679813-912ffc00-5944-11e9-9f11-4b1515b03c37.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losergzr's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java多线程编程-锁</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T07:03:31+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="并发编程的问题引入"><a href="#并发编程的问题引入" class="headerlink" title="并发编程的问题引入"></a>并发编程的问题引入</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性这个问题，聊得最多的demo还是 <code>i++</code> 问题， <code>i++</code> 看起来是一步操作，其实做了两个运算，先加1再重新赋值给i；如果多个线程都会来操作这个 <code>i++</code> 操作的时候就很可能会出现线程 A 执行的时候 加了1但是还没赋值，然后B又来加了个1，最后A再运行赋值操作，这也就是天天挂在嘴边上的原子性的例子了，就不给demo举例了。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值，必须把这个值刷新到内存里面区让其他线程更新。</p>
<p>在Java中，synchronized关键字、Lock对象和volatile关键字都可以实现共享变量的可见性。关于可见性的问题，这涉及到硬件的内存模型。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>volatile 关键字可以保证一定的有序性，也可以通过使用 <code>synchronized</code> 和 <code>Lock</code> 来保证有序性， <code>synchronized</code> 和 <code>Lock</code> 保证了某个时刻只有一个线程在执行同步代码，相当于是让线程顺序执行同步代码，保证了可见性。</p>
<p>为什么会出现有序性问题？因为指令重排序。指令重排序即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以和代码的顺序不一致，这个过程叫指令的重排序。</p>
<p>JVM 能根据处理器的特性对机器指令进行重排序，使机器指令的执行能更符合 CPU 的执行特性，最大限度的发挥机器性能。</p>
<a id="more"></a>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a><code>happens-before</code> 原则</h3><p>Java 内存模型中存在一些先天的有序性，即不用通过任何手段就可以保证有序性，这个也通常称为 <code>happens-before</code> 原则。如果两个操作的执行次序不能通过 <code>happens-before</code> 原则推导出来，那么这俩操作的有序性就不能被保证到，虚拟机可以随意地对他们进行重排序。</p>
<ul>
<li>程序次序规则： 一个线程内，按照代码的顺序，书写在前面的操作先行发生在书写在后面的操作</li>
<li>锁定规则： 一个锁的 <code>unLock</code> 操作先于后面对同一个锁的 <code>lock</code> 操作</li>
<li>volatile变量规则： 对一个变量的写操作先于后面对这个变量的读操作，如果一个线程先去写一个变量，然后一个线程去读，那么写入操作一定会先发生于读操作之前</li>
<li>传递规则： 如果 A 操作先发生于 B 操作，B 操作又先发生于 C 操作，那么 A 操作先发生于 C 操作</li>
<li>线程启动规则： <code>Thread</code> 对象的 <code>start()</code> 操作先发生于线程的每一个动作</li>
<li>线程中断规则： 对线程 <code>interrupt()</code> 方法的调用先发生于检测到中断事件发生</li>
<li>线程终结规则： 线程中的所有操作都先发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束，<code>Thread.isAlive（）</code>的返回值检测已经终止执行</li>
<li>对象终结规则： 一个对象初始化的完成先于它 <code>finalize()</code> 方法的开始</li>
</ul>
<h2 id="Java-中锁的种类"><a href="#Java-中锁的种类" class="headerlink" title="Java 中锁的种类"></a>Java 中锁的种类</h2><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。</p>
<p>公平锁的好处是等待锁的线程不会饿死，但是整体效率相对低一些；</p>
<p>非公平锁的好处是整体效率相对高一些，但是有些线程可能会饿死或者说很早就在等待锁，但要等很久才会获得锁。其中的原因是公平锁是严格按照请求所的顺序来排队获得锁的，而非公平锁时可以抢占的，即如果在某个时刻有线程需要获取锁，而这个时候刚好锁可用，那么这个线程会直接抢占，而这时阻塞在等待队列的线程则不会被唤醒。</p>
<p>公平锁可以使用 <code>new ReentrantLock(true)</code> 实现，无参构造方法 <code>new ReentrantLock()</code> 默认使用的是非公平锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul>
<li>内核态（Kernel Mode）：运行操作系统程序</li>
<li>用户态（User Mode）：运行用户程序</li>
</ul>
<p>Java 中如果需要阻塞和唤醒一个线程，都需要操作系统帮忙完成，需要从用户态转换到核心态中，状态转换会耗费大量 CPU 时间，对于一些简单的同步代码块来说，状态切换消耗的时间可能比线程任务执行需要的时间都还要长。</p>
<p>如果某些同步代码块本来就只需要执行很少的一段时间，为了这段时间挂起和恢复现场不值得，如果是多核处理器，我们可以让后面请求那个锁的线程稍微等一下，正在执行的这个线程不放弃锁，为了让另一个线程等待，我们需要让这个线程执行一个忙循环，也就是自旋，也就是我们说的自旋锁的实现。</p>
<p>自旋等待不能代替阻塞。自旋等待虽然避免了线程切换的开销，但是如果等待时间过长，自旋锁也是浪费了很多处理器的资源，因此自旋锁的等待时间需要有一定的限度，如果自旋超过了限定次数（默认10次，可以使用 -XX：PreBlockSpin来更改）都还没拿到锁，就应该使用传统的方式挂起线程了。</p>
<h4 id="真实的比喻"><a href="#真实的比喻" class="headerlink" title="真实的比喻"></a>真实的比喻</h4><p>A，B两个人合租一套房子，共用一个厕所，那么这个厕所就是共享资源，且在任一时刻最多只能有一个人在使用。当厕所闲置时，谁来了都可以使用，当A使用时，就会关上厕所门，而B也要使用，但是急啊，就得在门外焦急地等待，急得团团转，是为“自旋”，这也是要求锁的持有时间尽量短的原因！</p>
<h4 id="开启自旋锁"><a href="#开启自旋锁" class="headerlink" title="开启自旋锁"></a>开启自旋锁</h4><p>自旋锁在 JDK6 中默认开启，并且引入了自适应的自旋锁，意味着自旋的时间不再固定了，由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定。</p>
<p>自旋在轻量级锁中使用的，重量级锁中线程不适用自旋。</p>
<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋很可能再次成功，然后它可能会把自旋等待的时间设置的比上次更长。如果对于某个锁自旋很少成功获得过，那么以后获取这个锁可能不会再去自旋了。</p>
<h4 id="自旋锁的特点"><a href="#自旋锁的特点" class="headerlink" title="自旋锁的特点"></a>自旋锁的特点</h4><ul>
<li>用于临界区互斥</li>
<li>任何时候至多只能有一个执行单元获得锁</li>
<li>要求持有锁的处理器所占用的时间尽可能短</li>
<li>等待锁的线程进入忙循环</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是在虚拟机 JIT 在运行时，对一些代码要求同步，但是被检测到又不可能存在共享数据竞争的关系，就会对锁进行消除，虽然这个数据可能在堆上，但是咱们也可以把它当成在栈上来看待。</p>
<p>比如下面的代码，sb 是 <code>StringBuffer</code> 类的实例，但是这是个局部变量，其他线程访问不到。我们知道 <code>StringBuffer</code> 的 <code>append()</code> 方法是个同步方法，这不就是多此一举了吗，用个 <code>StringBuilder</code> 不是美滋滋。。但是在即时编译之后，这段代码会忽略所有的同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上我们总是把临界区找到的足够精准，也就是同步块尽量的小，避免不需要的性能消耗。</p>
<p>举个案例，类似锁消除的 <code>append()</code> 方法。如果 <code>StringBuffer sb = new StringBuffer();</code> 定义在方法体之外，那么就会有线程竞争，但是每个 <code>append()</code> 操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个 <code>append()</code> 操作之前和最后一个<code>append()</code> 操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁，指的就是同一个线程外层函数获得锁之后，内层递归函数仍然可以获取该锁，<code>ReentrantLock</code> 和 <code>synchronized</code> 都是可重入锁，最大的作用就是用来规避死锁。</p>
<h3 id="类锁和对象锁"><a href="#类锁和对象锁" class="headerlink" title="类锁和对象锁"></a>类锁和对象锁</h3><p>类锁：在方法上加上static synchronized的锁，或者synchronized(xxx.class)的锁。</p>
<p>对象锁： new 个对象用来当锁用</p>
<h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><p><code>synchronized</code> 的偏向锁、轻量级锁和重量级锁都是通过 Java 对象头实现的。对象头可以分为 <code>Mark Word</code> 和类型指针klass。<code>Mark Word</code> 是关键，默认情况下，其存储对象的 <code>HashCode</code>、分代年龄和锁标记位。</p>
<p>以 <code>HotSpot</code> 虚拟机为基准，看一下 <code>Mark Word</code> 的内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">锁状态</th>
<th style="text-align:center">存储内容</th>
<th style="text-align:center">标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无锁</td>
<td style="text-align:center">对象的hashCode，对象的分代年龄，是否是偏向锁（0）</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">轻量级锁</td>
<td style="text-align:center">指向栈帧中锁记录的指针</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">重量级锁</td>
<td style="text-align:center">指向互斥量（重量级锁）的指针</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">GC标记</td>
<td style="text-align:center">（空）</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td style="text-align:center">01</td>
</tr>
</tbody>
</table>
<p>偏向锁是 JDK6 引入的一项锁优化，目的在于消除数据在无竞争情况下的同步原语，提高程序的性能。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁主要干啥事呢？偏向锁会偏向于第一个获得这个锁的线程，如果在后面的执行过程中，都是这个线程重复获得这个锁，那么这段代码好像永远也不需要同步。大多数情况下锁不存在线程竞争，而是由一个线程多次获得，为了让线程获得锁的代价更低就引入了偏向锁。</p>
<p><strong>成功</strong>： 对象第一次被线程获取的时候，线程就是用 CAS 操作把这个锁的线程 ID 记录在 <code>Mark Word</code> 中，同时置偏向标志位为1，以后这个线程在进入和退出同步代码块都不需要进行 CAS 操作来进行加锁和解锁，只需要看一下对象头的 <code>Mark Word</code> 里面是不是存在指向当前线程的偏向锁，如果测试成功就表明获得了锁。</p>
<p><strong>失败</strong>： 如果使用 CAS 操作失败表示这个锁存在多个线程的竞争关系，并且这个时候另一个线程获得偏向锁获得偏向锁的使用权，当到达全局安全点（safepoint，这个时间点上没有正在执行的字节码）时获得偏向锁的线程被挂起，膨胀为轻量级锁，同时被撤销偏向锁的线程继续往下执行同步代码。</p>
<p>当有另一个线程获取这个锁偏向模式就宣告结束了。</p>
<h4 id="轻量级锁和重量级锁"><a href="#轻量级锁和重量级锁" class="headerlink" title="轻量级锁和重量级锁"></a>轻量级锁和重量级锁</h4><p><strong>偏向锁/轻量级锁/重量级锁</strong>这三种锁是指锁的状态，并且是针对synchronized。在Java 5通过引入锁升级的机制来实现高效 <code>synchronized</code>。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>
<p>线程在执行同步块之前，JVM 会在当前线程的栈帧中创建用于存储锁记录的空间，并且将对象头 <code>Mark Word</code> 复制到锁记录中，然后线程尝试使用 CAS 将对象头中的 <code>Mark Word</code> 替换为指向锁记录的指针，如果成功线程获得锁，如果失败表示其他线程竞争锁，然后当前线程就以自旋来获取锁，如果自旋失败锁就会膨胀为重量级锁，如果自旋成功就还是轻量级锁。</p>
<p>轻量级锁的解锁过程也是通过 CAS 操作来完成的，如果对象的 <code>Mark Word</code> 仍然指向线程的锁记录，那就用CAS操作把对象当前的 <code>Mark Word</code> 和线程中赋值的 <code>Displaced Mark Word</code> 替换回来，如果替换成功，整个同步过程就完成了，如果替换失败，就说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的（区别于偏向锁）。这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。</p>
<p>整个 <code>synchronized</code> 锁流程如下：</p>
<ol>
<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>
<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li>
<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>当前线程使用CAS将对象头的 <code>Mark Word</code> 替换为锁记录指针，如果成功，当前线程获得锁</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li>如果自旋成功则依然处于轻量级状态。</li>
<li>如果自旋失败，则升级为重量级锁。</li>
</ol>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>乐观锁：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。（使用版本号或者时间戳来配合实现）</p>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。</p>
<p>独占锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。</p>
<p>对于 <code>ReentrantLock</code> 而言，其是独享锁。但是对于 <code>Lock</code> 的另一个实现类 <code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写、写读 、写写的过程是互斥的。独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法，来实现独享或者共享。对于 <code>synchronized</code> 而言，当然是独享锁。</p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁是一种锁的设计，</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁是一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>所谓互斥锁就是指一次最多只能有一个线程持有的锁。在 JDK 中 <code>synchronized</code> 和 JUC 的 <code>Lock</code> 就是互斥锁。</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<ol>
<li>无状态编程。无状态代码有一些共同的特征：不依赖于存储在对上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。</li>
<li>线程本地存储。可以参考ThreadLocal</li>
<li>volatile</li>
<li>CAS</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ol>
<h2 id="Java中锁的实现"><a href="#Java中锁的实现" class="headerlink" title="Java中锁的实现"></a>Java中锁的实现</h2><p><code>Lock</code> 是 JUC 包的顶层接口，<code>ReentrantLock</code> 的继承关系图如下：</p>
<p><img src="https://user-images.githubusercontent.com/20592210/57584778-d29e6300-7511-11e9-9cea-65ac04c6e31f.png" alt="ReentrantLock"></p>
<p><code>ReentrantLock</code> 对 <code>Lock</code> 接口的实现主要依赖了 <code>Sync</code>， 而 <code>Sync</code> 继承了 <code>AbstractQueuedSynchronizer（AQS）</code>，它是 JUC 包实现同步的基础工具，AQS 中定义了一个 <code>private volatile int state;</code> 作为共享资源，如果线程获取资源失败就会进入同步 FIFO 队列进行等待，如果成功获取资源就执行临界区代码。释放完资源时，会通知同步队列中的等待线程来获取资源后出队并执行。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 是抽象类，内置<strong>自旋锁</strong>实现的同步队列，封装入队出队操作，提供了独占、共享、中断等特性的方法，AQS 的子类可以根据定义不同的资源实现不同性质的方法，许多同步类都依赖于它，比如常见的 <code>ReentrantLock/Semaphore/CountDownLatch</code>。</p>
<p><img src="https://user-images.githubusercontent.com/20592210/57590966-8b3fc300-7561-11e9-9820-a2df4ead835e.png" alt="image"></p>
<p>AQS 维护了一个共享资源变量 <code>volatile int state</code> 和一个 FIFO 线程等待队列，state有如下三个操作方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="AQS定义了两种资源共享方式"><a href="#AQS定义了两种资源共享方式" class="headerlink" title="AQS定义了两种资源共享方式"></a>AQS定义了两种资源共享方式</h4><ul>
<li>独占：（Exclusive，只有一个线程能执行，比如 <code>ReentrantLock</code>）</li>
<li>共享： (Shared，多个线程可同时执行，比如 <code>CountDownLatch/Semaphore</code>)</li>
</ul>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>比如可重入锁 <code>ReentrantLock</code>，定义为 state 为0的时候可以获取资源并置为1，若已经获得资源，A 线程 <code>lock()</code> 的时候会调用 <code>tryAccquire()</code> 独占该锁并将 <code>state + 1</code>,后面其他线程 <code>tryAccquire()</code> 就会失败，知道 A 线程 <code>unLock()</code> 到 <code>state = 0</code>为止，其他线程就可以获取这个锁了。A 线程是可以持续获得同一个锁的，每次都会让 <code>state + 1</code>，这也就是可重如的概念。</p>
<p><code>CountDownLatch</code> 初始化的时候就制定了资源的总量，<code>state</code> 会被初始化为 n，<code>countDown()</code> 方法不断地以 CAS 将 state 减 1，state 为 0 的时候获得锁，释放后 state 一直为 0，这个时候 <code>await()</code> 就不会继续阻塞了，所有 <code>CountDownLatch</code> 是一次性的，用完之后再想用就得重新创建一个，如果要循环使用可以考虑下 <code>CyclicBarrier</code>。</p>
<p>一般来说自定义同步器要么是独占，要么是共享，所以以后一般实现一组 <code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code>。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>CAS(Compare And Swap)</code> 是乐观锁技术,多个线程同时更新一个共享变量的时候，只有一个会成功，其他的都会失败，因为更新之前线程都会比较下当前共享变量的值还是不是之前获得的值，如果不是那么这次更新变量值就会失败，失败的线程并不会被挂起，而是知道这次更新失败并且可以再次进行尝试更新。</p>
<p>CAS操作中包含三个操作数</p>
<ul>
<li>需要读写的内存位置(V)、</li>
<li>进行比较的预期原值(A)</li>
<li>拟写入的新值(B)</li>
</ul>
<p>如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B，否则处理器不做任何操作。无论哪种情况，它都会在CAS 指令之前返回该位置的值（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值）。</p>
<p>CAS有效地说明了:我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。这其实和乐观锁的冲突检查 + 数据更新的原理是一样的。</p>
<p>JUC 包就是建立在 CAS 之上的，相比同步阻塞， CAS 是一种更好的实现方式</p>
<p>比如 <code>AtomicInteger</code> 类,下面这个方法就是 JDK8 中 <code>AtomicInteger</code> 实现原子操作的实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Unsafe</code> 类的加法方法</p>
<ul>
<li>var1 是atomicInteger对象</li>
<li>var2 内存地址</li>
<li>var4 新增的值</li>
</ul>
<p>一个 do-while 循环判断如果替换失败就重试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>AtomicInteger</code> 中使用到一个 <code>Unsafe</code> 类，这个 <code>Unsafe</code> 类可以像 C 语言一样直接操作内存指针，里面的所有方法都有一个 <code>native</code> 修饰符，也就是都是调用操作系统的本地方法。</p>
<p><code>valueOffset</code> 是用来记录 value 本身在内存的偏移地址的，这个记录，也主要是为了在更新操作在内存中找到 value 的位置，方便比较，可以看到 <code>AtomicInteger</code> 的这个静态代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          valueOffset = unsafe.objectFieldOffset</span><br><span class="line">              (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="CAS-带来的问题-—-ABA"><a href="#CAS-带来的问题-—-ABA" class="headerlink" title="CAS 带来的问题 — ABA"></a>CAS 带来的问题 — ABA</h4><p>ABA 问题：线程 X 获取到变量值为 A，线程 Y 也获取到变量值为 A，现在 线程 X 先将 变量的值改为 B，再将值改成 A，这个时候线程 Y 来执行发现变量的值是 A，就认为它没有变可以直接替换，这样认为对么？</p>
<h4 id="ABA-问题如何-解决"><a href="#ABA-问题如何-解决" class="headerlink" title="ABA 问题如何 解决"></a>ABA 问题如何 解决</h4><p>用 <code>AtomicStampedReference/AtomicMarkableReference</code> 解决ABA问题</p>
<p><code>AtomicStampedReference</code> 里面维护了一个版本戳 <code>final int stamp</code> 可以解决 ABA 问题。</p>
<p><code>AtomicMarkableReference</code> 里面通过一个布尔值 <code>final boolean mark</code> 来记录是否已经被修改过。</p>
<h2 id="Java-中锁的使用"><a href="#Java-中锁的使用" class="headerlink" title="Java 中锁的使用"></a>Java 中锁的使用</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2 enter thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"3 get thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//调用set方法验证是否可重入，因为同一个实例的两个synchronized方法都要得是这个实例this锁</span></span><br><span class="line">        set();</span><br><span class="line">        System.out.println(<span class="string">"5 leave run thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"4 set thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 run thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedTest test = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(test, <span class="string">"test-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多运行几次会有不同的结果。比如下面这个结果，根据结果可以发现 <code>get()</code> 调用 <code>set()</code> 并没有被阻塞证明是可以重入的，并且 线程1最后运行，但是线程1比线程2先来啊，证明 <code>synchronized</code> 是一个非公平锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 run thread name--&gt;test-0</span><br><span class="line">2 enter thread name--&gt;test-0</span><br><span class="line">3 get thread name--&gt;test-0</span><br><span class="line">4 set thread name--&gt;test-0</span><br><span class="line">5 leave run thread name--&gt;test-0</span><br><span class="line">1 run thread name--&gt;test-2</span><br><span class="line">1 run thread name--&gt;test-1</span><br><span class="line">2 enter thread name--&gt;test-2</span><br><span class="line">3 get thread name--&gt;test-2</span><br><span class="line">4 set thread name--&gt;test-2</span><br><span class="line">5 leave run thread name--&gt;test-2</span><br><span class="line">2 enter thread name--&gt;test-1</span><br><span class="line">3 get thread name--&gt;test-1</span><br><span class="line">4 set thread name--&gt;test-1</span><br><span class="line">5 leave run thread name--&gt;test-1</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 既可以是公平锁，也可以是非公平锁，因为它的内部抽象类 <code>Sync</code> 继承了 <code>AbstractQueuedSynchronizer</code>，并且有两个具体实现。</p>
<ul>
<li><code>lock()</code>： 获取锁</li>
<li><code>unlock()</code>： 释放锁 </li>
<li><code>tryLock()</code>: 它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</li>
<li><code>tryLock(long time, TimeUnit unit)</code>: 方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li>
<li><code>lockInterruptibly()</code>:  <code>lock.lockInterruptibly()</code> 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 <code>threadB.interrupt()</code> 方法能够中断线程B的等待过程。</li>
</ul>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p><code>ReentrantLock</code> 默认的构造方法就是非公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoFairReentrantLockTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2 enter thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"3 get thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        set();</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">"5 leave run thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"4 set thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 run thread name--&gt;"</span> + Thread.currentThread().getName());</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedTest test = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(test, <span class="string">"test-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下，跟 <code>synchronized</code> 输出结果类似，可重入并且非公平，因为 test-1 不是第二个运行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 run thread name--&gt;test-0</span><br><span class="line">1 run thread name--&gt;test-1</span><br><span class="line">2 enter thread name--&gt;test-0</span><br><span class="line">3 get thread name--&gt;test-0</span><br><span class="line">1 run thread name--&gt;test-2</span><br><span class="line">4 set thread name--&gt;test-0</span><br><span class="line">5 leave run thread name--&gt;test-0</span><br><span class="line">2 enter thread name--&gt;test-2</span><br><span class="line">3 get thread name--&gt;test-2</span><br><span class="line">4 set thread name--&gt;test-2</span><br><span class="line">5 leave run thread name--&gt;test-2</span><br><span class="line">2 enter thread name--&gt;test-1</span><br><span class="line">3 get thread name--&gt;test-1</span><br><span class="line">4 set thread name--&gt;test-1</span><br><span class="line">5 leave run thread name--&gt;test-1</span><br></pre></td></tr></table></figure>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>下面这个代码实现的就是一个公平锁，会按照队列顺序来。</p>
<p><code>private Lock lock = new ReentrantLock(true);</code></p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p><code>Condition</code> 是在 <code>JDK1.5</code> 中才出现的，它用来替代传统的 <code>Object</code> 的 <code>wait()</code> 、<code>notify()</code> 实现线程间的协作，相比使用 <code>Object</code> 的 <code>wait()</code>、<code>notify()</code>，使用 <code>Condition</code> 的 <code>await()</code>、<code>signal()</code> 这种方式实现线程间协作更加安全和高效。</p>
<p>因此通常来说比较推荐使用 <code>Condition</code>，<code>Conditon</code>中的 <code>await()</code> 对应 <code>Object</code> 的 <code>wait()</code>；<code>Condition</code> 中的 <code>signal()</code> 对应 <code>Object</code> 的 <code>notify()</code> ；<code>Condition</code> 中的 <code>signalAll()</code> 对应 <code>Object</code> 的 <code>notifyAll()</code>;</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>读写锁的性能都会比排它锁要好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。JUC 提供读写锁的实现是 <code>ReentrantReadWriteLock</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公平性选择</td>
<td style="text-align:center">支持非公平(默认)和公平的锁获取方式，吞吐量还是非公平优于公平</td>
</tr>
<tr>
<td style="text-align:center">重进入</td>
<td style="text-align:center">该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td style="text-align:center">锁降级</td>
<td style="text-align:center">遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</td>
</tr>
</tbody>
</table>
<p>里面一个读锁一个写锁，读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/06/Java线程安全/" rel="next" title="Java线程安全">
                <i class="fa fa-chevron-left"></i> Java线程安全
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/11/Java多线程编程-线程池/" rel="prev" title="Java多线程编程-线程池">
                Java多线程编程-线程池 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://user-images.githubusercontent.com/20592210/55679813-912ffc00-5944-11e9-9f11-4b1515b03c37.png"
                alt="ggzr" />
            
              <p class="site-author-name" itemprop="name">ggzr</p>
              <p class="site-description motion-element" itemprop="description">一只咸鱼的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发编程的问题引入"><span class="nav-number">1.</span> <span class="nav-text">并发编程的问题引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">1.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性"><span class="nav-number">1.2.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性"><span class="nav-number">1.3.</span> <span class="nav-text">有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before-原则"><span class="nav-number">1.4.</span> <span class="nav-text">happens-before 原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中锁的种类"><span class="nav-number">2.</span> <span class="nav-text">Java 中锁的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#公平锁和非公平锁"><span class="nav-number">2.1.</span> <span class="nav-text">公平锁和非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">2.2.</span> <span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#真实的比喻"><span class="nav-number">2.2.1.</span> <span class="nav-text">真实的比喻</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开启自旋锁"><span class="nav-number">2.2.2.</span> <span class="nav-text">开启自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁的特点"><span class="nav-number">2.2.3.</span> <span class="nav-text">自旋锁的特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁消除"><span class="nav-number">2.3.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁粗化"><span class="nav-number">2.4.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入锁"><span class="nav-number">2.5.</span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类锁和对象锁"><span class="nav-number">2.6.</span> <span class="nav-text">类锁和对象锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁、轻量级锁、重量级锁"><span class="nav-number">2.7.</span> <span class="nav-text">偏向锁、轻量级锁、重量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁"><span class="nav-number">2.7.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级锁和重量级锁"><span class="nav-number">2.7.2.</span> <span class="nav-text">轻量级锁和重量级锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁和乐观锁"><span class="nav-number">2.8.</span> <span class="nav-text">悲观锁和乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享锁和独占锁"><span class="nav-number">2.9.</span> <span class="nav-text">共享锁和独占锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段锁"><span class="nav-number">2.10.</span> <span class="nav-text">分段锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">2.11.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁"><span class="nav-number">2.12.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无锁"><span class="nav-number">2.13.</span> <span class="nav-text">无锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中锁的实现"><span class="nav-number">3.</span> <span class="nav-text">Java中锁的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">3.1.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS定义了两种资源共享方式"><span class="nav-number">3.1.1.</span> <span class="nav-text">AQS定义了两种资源共享方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">3.2.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-带来的问题-—-ABA"><span class="nav-number">3.2.1.</span> <span class="nav-text">CAS 带来的问题 — ABA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ABA-问题如何-解决"><span class="nav-number">3.2.2.</span> <span class="nav-text">ABA 问题如何 解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中锁的使用"><span class="nav-number">4.</span> <span class="nav-text">Java 中锁的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">4.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">4.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非公平锁"><span class="nav-number">4.2.1.</span> <span class="nav-text">非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#公平锁"><span class="nav-number">4.2.2.</span> <span class="nav-text">公平锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition"><span class="nav-number">4.3.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">4.4.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ggzr</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
